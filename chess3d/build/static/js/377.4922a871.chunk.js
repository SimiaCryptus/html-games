(()=>{"use strict";function e(e,t,o){return{x:e,y:t,boardId:o}}function t(e){return s(e)?e.x:Math.sqrt(3)/2*e.q}function o(e){return s(e)?e.y:3/4*e.r}function i(e,t){if(s(e))return{...e,x:t};{const o=2/Math.sqrt(3)*t;return{...e,q:o,s:-o-e.r}}}function r(e,t){if(s(e))return{...e,y:t};{const o=4/3*t;return{...e,r:o,s:-e.q-o}}}function s(e){return"x"in e&&"y"in e}function n(e){return"q"in e&&"r"in e&&"s"in e}const a=["1","2","3","4","5","6","7","8"],c=["a","b","c","d","e","f","g","h"];function l(e){if("object"===typeof(t=e)&&(s(t)||n(t)))return e;var t;if(Array.isArray(e))return{x:e[0],y:e[1],z:e[2]};if("string"===typeof e){const[t,o]=e.split("");return{x:c.indexOf(t),y:a.indexOf(o)}}throw new Error("Invalid position format")}function h(e,t){if(s(e)&&s(t))return e.x==t.x&&(e.y==t.y&&((null==e.boardId||null==t.boardId||e.boardId==t.boardId)&&(null==e.z||null==t.z||e.z==t.z)));if(n(e)&&n(t)){const o=d(e),i=d(t);return o.q==i.q&&o.r==i.r&&o.s==i.s&&(null==e.boardId||null==t.boardId||e.boardId==t.boardId)}return!1}function u(e){return s(e)?"".concat(e.boardId?e.boardId+":":"").concat(c[e.x]).concat(a[e.y]):"".concat(e.boardId?e.boardId+":":"").concat(e.q,",").concat(e.r)}function d(e){if(n(e)){let{q:t,r:o,s:i}=e;return t+o+i!==0&&(i=-t-o),{q:t,r:o,s:i}}return e}class g{constructor(){this.pieceValues=new Map,this.verbosityLevel=0,this.gameModel=void 0,this.config=void 0,this.evaluationWeights={kingSafety:200,material:100,pieceActivity:10,mobility:10,pawnStructure:20,center:15,development:15,pieceSafety:150},this.pieceValues=new Map([["pawn",100],["knight",320],["bishop",330],["rook",500],["queen",900],["king",2e4]])}initialize(e,t){this.gameModel=e,this.config=t,this.verbosityLevel=t.verbosityLevel||0,t.evaluationWeights&&(this.evaluationWeights={...this.evaluationWeights,...t.evaluationWeights}),console.log("Initializing BasicAIPlayer: config=".concat(JSON.stringify(t)))}async calculateBestMove(e){if(!e||!e.currentTurn)return console.error("Invalid game state received in calculateBestMove"),Promise.resolve(null);console.log("AI Move: ".concat(e.currentTurn," - ").concat(JSON.stringify(this.config))),this.verbosityLevel>=1&&console.group("calculateBestMove");const t=this.config.depthLimit||3;this.verbosityLevel>=1&&console.log("Search Depth: ".concat(t,", Time Limit: ").concat(this.config.timeLimit||5e3,"ms"));let o=[];const i=this.getLegalMoves(e);if(0===i.length)return this.verbosityLevel>=0&&console.error("No legal moves available. Possible stalemate or checkmate."),this.verbosityLevel>=1&&console.groupEnd(),null;o=i.map((t=>({move:t,score:this.evaluatePosition(this.gameModel.makeMove(e,t),e.currentTurn)}))),this.verbosityLevel>=1&&console.log("Total Legal Moves: ".concat(i.length));const r=Date.now(),s=this.config.timeLimit||5e3;return 0===i.length?(console.error("No legal moves found. Returning null."),null):new Promise(((n,a)=>{const c=(a,l)=>{let h=this,d=h.verbosityLevel;function g(){if(0===o.length)return d>=0&&console.error("No valid moves found within tim e limit"),void n(null);const e=h.selectMoveWithRandomness(o);if(null===e)return d>=0&&console.error("No valid moves available after selection"),void n(null);d>=1&&console.log("Selected move: ".concat(e.piece.type," ").concat(u(e.from)," -> ").concat(u(e.to))),d>=1&&console.groupEnd(),n(e)}if(Date.now()-r>s)return d>=1&&console.log("Time limit reached."),void g.call(this);for(let r=a;r<l&&r<i.length;r++){const s=i[r];let n=0;this.verbosityLevel>=1&&console.group("Evaluating move ".concat(r+1,"/").concat(i.length,": ").concat(s.piece.color," ").concat(s.piece.type," ").concat(u(s.from)," -> ").concat(u(s.to)));try{const i=performance.now();n=-this.negamax(t-1,this.gameModel.makeMove(e,s)),this.verbosityLevel>=1&&(console.log("Move evaluation time: ".concat((performance.now()-i).toFixed(2),"ms")),console.log("Score: ".concat(n))),o=o.filter((e=>e.move!==s)),o.push({move:s,score:n})}catch(v){this.verbosityLevel>=0&&console.error("Error evaluating move: ".concat(v.message)),this.verbosityLevel>=1&&console.error("Current state during error:",JSON.stringify(e,null,2)),this.verbosityLevel>=1&&console.error("Current state during error:",JSON.stringify(e,null,2)),this.verbosityLevel>=1&&console.error("Move causing error:",JSON.stringify(s,null,2))}finally{this.verbosityLevel>=1&&console.groupEnd(),d>=2&&console.log("Move: ".concat(s.piece.color," ").concat(s.piece.type," from ").concat(u(s.from)," to ").concat(u(s.to),", Score: ").concat(n))}}l>=i.length?g.call(this):setTimeout((()=>c(l,l+10)),0)};c(0,10)}))}abortCalculation(){this.verbosityLevel>=0&&console.error("AI calculation aborted")}evaluatePosition(e,t){return[{value:this.evaluateKingSafety(e,t),weight:this.evaluationWeights.kingSafety},{value:this.evaluateMaterial(e,t),weight:this.evaluationWeights.material},{value:this.evaluatePieceActivity(e,t),weight:this.evaluationWeights.pieceActivity},{value:this.evaluateMobility(e,t),weight:this.evaluationWeights.mobility},{value:this.evaluatePawnStructure(e,t),weight:this.evaluationWeights.pawnStructure},{value:this.evaluateCenter(e,t),weight:this.evaluationWeights.center},{value:this.evaluateDevelopment(e,t),weight:this.evaluationWeights.development},{value:this.evaluatePieceSafety(e,t),weight:this.evaluationWeights.pieceSafety}].reduce(((e,t)=>e+t.value*t.weight),0)}evaluatePawnStructure(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.currentTurn,o=0;const i=e.board.filter((e=>"pawn"===e.type&&e.color===t));o-=this.evaluateDoubledPieces(i),o-=this.evaluateIsolatedPieces(i);const r=e.board.filter((e=>"pawn"===e.type&&e.color!==t));return o+=this.evaluateAdvancedPieces(i,r),this.verbosityLevel>=3&&console.log("Evaluated pawn structure for ".concat(t,": ").concat(o)),o}getLegalMoves(e){this.verbosityLevel>=3&&(console.group("getLegalMoves"),console.log("Current turn: ".concat(e.currentTurn)));try{const t=e.board.filter((t=>t.color===e.currentTurn)).flatMap((t=>{const o=this.gameModel.calculatePossibleMoves(e,t);return this.verbosityLevel>=3&&console.log("Possible moves for ".concat(t.color," ").concat(t.type," at ").concat(u(t.position),":"),o.map(u)),o.map((e=>({from:t.position,to:e,piece:t})))}));return this.verbosityLevel>=3&&console.log("Total legal moves found: ".concat(t.length)),t}finally{this.verbosityLevel>=3&&console.groupEnd()}}evaluateKingSafety(e){var i;let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.currentTurn,s=0;const n=null===(i=e.board)||void 0===i?void 0:i.find((e=>"king"==e.type&&e.color==r));if(!n||!e.board)return this.verbosityLevel>=1&&console.warn("No ".concat(r," king found on the board. Returning default score.")),0;this.gameModel.isInCheck(e,r)&&(s-=50);return s+=10*e.board.filter((e=>e.color==r&&Math.abs(t(e.position)-t(n.position))<=1&&Math.abs(o(e.position)-o(n.position))<=1)).length,this.verbosityLevel>=3&&console.log("King safety for ".concat(r,": ").concat(s)),s}calculateMobilityScore(e,t){let o=this.getLegalMoves(t).filter((t=>t.piece.color==e)).length;return this.verbosityLevel>=3&&console.log("Mobility score for ".concat(e,": ").concat(o)),o}evaluatePieceSafety(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.currentTurn,o=0;for(const i of e.board){const r=this.gameModel.getAttackersOfSquare(e,i.position,"white"===i.color?"black":"white"),s=this.gameModel.getAttackersOfSquare(e,i.position,i.color);if(r&&r.length>0){const e=this.pieceValues.get(i.type)||0,n=Math.min(...r.map((e=>this.pieceValues.get(e.type)||0))),a=e*r.length/(((null===s||void 0===s?void 0:s.length)||1)*Math.max(n,1));o+=i.color===t?-a:a}}return o}logMove(e,t,o){this.verbosityLevel>=2&&console.log("Move: ".concat(e.piece.color," ").concat(e.piece.type," from ").concat(u(e.from)," to ").concat(u(e.to),", Score: ").concat(t,", Depth: ").concat(o))}negamax(e,t){if(!t||!t.currentTurn)return console.error("Invalid game state received in negamax"),0;t.currentTurn;const o=this.verbosityLevel,i=this.gameModel,r=this;return function e(t,s,n,a){const c=a.currentTurn;o>=2&&console.group("Negamax: depth=".concat(t,", alpha=").concat(s,", beta=").concat(n));try{if(t<=0){let e=r.evaluatePosition(a,c);return o>=2&&console.log("Leaf node reached: depth=".concat(t,", score=").concat(e)),e}if(i.isInCheckmate(a,c))return o>=2&&console.log("Checkmate found at depth ".concat(t)),-2e4+t;if(i.isStalemate(a))return o>=2&&console.log("Stalemate found at depth ".concat(t)),0;const l=r.getLegalMoves(a);if(0===l.length)return o>=2&&console.log("No legal moves found at depth ".concat(t)),i.isInCheck(a,c)?-2e4+t:0;o>=2&&console.log("Legal moves at depth ".concat(t,": ").concat(l.length));let h=-1/0;for(const c of l){o>=2&&console.group("Evaluating move: ".concat(c.piece.color," ").concat(c.piece.type," from ").concat(u(c.from)," to ").concat(u(c.to)));try{const l=-e(t-1,-n,-s,i.makeMove(a,c));if(r.logMove(c,l,t),l>h&&(o>=2&&console.log("New best move found: ".concat(c.piece.type," from ").concat(u(c.from)," to ").concat(u(c.to),", score: ").concat(l)),h=l),l>s&&(o>=2&&console.log("New alpha: ".concat(c.piece.type," from ").concat(u(c.from)," to ").concat(u(c.to),", score: ").concat(l)),s=l),s>=n){o>=2&&console.log("New best move found: ".concat(c.piece.type," from ").concat(u(c.from)," to ").concat(u(c.to),", score: ").concat(l)),o>=2&&console.log("Beta cutoff at depth ".concat(t));break}}finally{o>=2&&console.groupEnd(),o>=2&&console.log("Move: ".concat(c.piece.color," ").concat(c.piece.type," from ").concat(u(c.from)," to ").concat(u(c.to),", Score: ").concat(h,", Alpha: ").concat(s,", Beta: ").concat(n))}}return o>=2&&console.log("Negamax result: ".concat(h)),h}finally{o>=2&&console.groupEnd()}}(e||3,-1/0,1/0,t)}evaluateCenter(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.currentTurn;const o=[r(i({},3),3),r(i({},3),4),r(i({},4),3),r(i({},4),4)];let s=0;for(const i of o){const o=this.gameModel.getPieceAt(e,i);o&&(s+=o.color===t?10:-10),s+=this.gameModel.isUnderAttack(e,i,t)?5:-5}return s}evaluateDevelopment(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.currentTurn,i=0;const r="white"===t?0:7;for(const s of e.board.filter((e=>e.color===t)))"pawn"!==s.type&&"king"!==s.type&&o(s.position)!==r&&(i+=10);return i}selectMoveWithRandomness(e){let t=this.config.randomnessFactor||.1;if(this.verbosityLevel>=2&&(e.forEach((e=>console.log("Move: ".concat(JSON.stringify(e.move),", Score: ").concat(e.score)))),console.log("Selecting move with randomness factor: ".concat(t))),e.sort(((e,t)=>t.score-e.score)),0===e.length)return this.verbosityLevel>=0&&console.error("No valid moves available"),null;const o=e.reduce(((e,o)=>e+Math.exp(o.score*t)),0),i=Math.random()*o;let r=0;for(let s=0;s<e.length;s++){const o=e[s];if(r+=Math.exp(o.score*t),i<=r)return e[s].move;this.verbosityLevel>=3&&console.log("Move ".concat(s,": ").concat(JSON.stringify(e[s].move),", Score: ").concat(e[s].score,", Weight: ").concat(o.score))}return e[0].move}evaluateMaterial(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.currentTurn,o=0;for(const i of e.board){const e=this.pieceValues.get(i.type)||0;o+=i.color==t?e:-e}return o}evaluatePieceActivity(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.currentTurn,o=0;for(const i of e.board){const r=this.gameModel.calculatePossibleMoves(e,i)||[];r&&(o+=r.length*(i.color===t?1:-1),r||this.verbosityLevel>=1&&console.error("No moves found for piece: ".concat(JSON.stringify(i))))}return this.verbosityLevel>=3&&console.log("Piece activity evaluation: ".concat(o)),o}evaluateMobility(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.currentTurn;const o=this.calculateMobilityScore("white",e),i=this.calculateMobilityScore("black",e);return"white"===t?o-i:i-o}evaluateDoubledPieces(e){return 10*-e.filter(((o,i)=>e.some(((e,r)=>i!==r&&h(o.position,e.position)&&t(o.position)===t(e.position))))).length}evaluateIsolatedPieces(e){return-(15*e.filter((o=>!e.some((e=>o!==e&&1===Math.abs(t(o.position)-t(e.position)))))).length)}evaluateAdvancedPieces(e,i){return 20*e.filter((e=>!i.some((i=>Math.abs(t(i.position)-t(e.position))<=1&&("white"==e.color&&o(i.position)>o(e.position)||"black"==e.color&&o(i.position)<o(e.position)))))).length}}class v{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];this.initialState=void 0,this.undoneMoves=[],this.className="MoveHistory",this.isInitializing=!1,this.moves=[],this.moves=[...t],this.initialState=[...e]}resetWithNewState(e){console.debug("".concat(this.className,": Resetting move history with new initial state")),this.initialState=[...e],this.clear()}addMove(e){if(this.isInitializing)return this;return this.moves.some((t=>h(t.from,e.from)&&h(t.to,e.to)))||(this.moves.push(e),this.undoneMoves=[],this.isInitializing=!1),this}getLastMove(){return this.moves.length>0?this.moves[this.moves.length-1]:null}clear(){this.moves=[],this.undoneMoves=[]}undoLastMove(){if(this.canUndo()){const e=this.moves.pop();return this.undoneMoves.push(e),{move:e,boardState:null}}return{move:null,boardState:null}}redoMove(){if(this.canRedo()){const e=this.undoneMoves.pop();return this.moves.push(e),e}return null}canRedo(){return this.undoneMoves.length>0}canUndo(){return this.moves.length>0}clone(){const e=new v(this.initialState,this.moves);return e.undoneMoves=[...this.undoneMoves],e.isInitializing=this.isInitializing,e}getUndoneMovesCount(){return this.undoneMoves.length}getMovesCount(){return this.moves.length}toString(){return this.moves.map((e=>"".concat(u(e.from),"-").concat(u(e.to)))).join(", ")}}const p={randomUUID:"undefined"!==typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};var m,f=new Uint8Array(16);function y(){if(!m&&!(m="undefined"!==typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return m(f)}for(var b=[],w=0;w<256;++w)b.push((w+256).toString(16).slice(1));function k(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return(b[e[t+0]]+b[e[t+1]]+b[e[t+2]]+b[e[t+3]]+"-"+b[e[t+4]]+b[e[t+5]]+"-"+b[e[t+6]]+b[e[t+7]]+"-"+b[e[t+8]]+b[e[t+9]]+"-"+b[e[t+10]]+b[e[t+11]]+b[e[t+12]]+b[e[t+13]]+b[e[t+14]]+b[e[t+15]]).toLowerCase()}const M=function(e,t,o){if(p.randomUUID&&!t&&!e)return p.randomUUID();var i=(e=e||{}).random||(e.rng||y)();if(i[6]=15&i[6]|64,i[8]=63&i[8]|128,t){o=o||0;for(var r=0;r<16;++r)t[o+r]=i[r];return t}return k(i)};class P{constructor(){this.type="standard",this.width=8,this.height=8,this.depth=1}getBoardSize(e){return this.width}getBoardPosition(e,t){return[0,0,0]}isValidPosition(e){const{x:t,y:o,z:i}=e;return t>=0&&t<this.width&&o>=0&&o<this.height&&(void 0===i||i>=0&&i<this.depth)}getAllPositions(){const e=[];for(let t=0;t<this.width;t++)for(let o=0;o<this.height;o++)e.push({x:t,y:o});return e}isWithinBoardBounds(e){return this.isValidPosition(e)}}class S{constructor(){this.geometry=void 0,this.geometry=new P}makeMove(e,t){e.capturedPieces||(e.capturedPieces={white:[],black:[]});const o=e.board.find((e=>h(e.position,t.from)&&e.type===t.piece.type&&e.color===t.piece.color));if(!o)return console.warn("No ".concat(t.piece.color," ").concat(t.piece.type," found at position: ").concat(u(t.from))),e;const i=this.getPieceAt(e,t.to),r={...e,board:e.board.filter((e=>e.id!==o.id)),currentTurn:"white"===e.currentTurn?"black":"white",moveHistory:new v(e.moveHistory.initialState,e.moveHistory.moves).addMove(t),capturedPieces:{white:[...e.capturedPieces.white],black:[...e.capturedPieces.black]}};if(i&&(r.capturedPieces[i.color].push(i),r.board=r.board.filter((e=>e.id!==i.id))),"pawn"!==o.type||0!==t.to.y&&7!==t.to.y)r.board.push({...o,position:t.to,hasMoved:!0});else{const e=t.promotionType||"queen";r.board.push({...o,position:t.to,hasMoved:!0,type:e})}if("king"===o.type&&2===Math.abs(t.to.x-t.from.x)){const o=t.to.x>t.from.x,i=o?7:0,s=o?t.to.x-1:t.to.x+1,n=this.getPieceAt(e,{x:i,y:t.from.y});n&&(r.board=r.board.filter((e=>e.id!==n.id)),r.board.push({...n,position:{x:s,y:t.from.y},hasMoved:!0}))}return r}getAttackersOfSquare(e,t,o){const i=l(t);return e.board.filter((t=>t.color===o&&this.calculatePossibleMoves(e,t).some((e=>h(e,i)))))}isLegalMove(e,t){const o=this.getPieceAt(e,t.from);return o?o.color!==e.currentTurn?(console.log("[StandardChessModel] It's not ".concat(o.color,"'s turn")),!1):!!this.isWithinBoardBounds(t.to)&&!!this.getLegalMovesForPiece(e,o).some((e=>h(e,t.to))):(console.log("[StandardChessModel] No piece found at position: ".concat(JSON.stringify(t.from))),!1)}isThreefoldRepetition(e){const t=e.moveHistory.moves.map((t=>this.getBoardStateString(e))).reduce(((e,t)=>(e[t]=(e[t]||0)+1,e)),{});return console.log("[StandardChessModel] Position counts:",t),Object.values(t).some((e=>e>=3))}getWinner(e){const t=e.board.find((e=>"king"===e.type&&"white"===e.color)),o=e.board.find((e=>"king"===e.type&&"black"===e.color));return t?o?t||o?this.isInCheckmate(e,"white")?(console.log("[StandardChessModel] Black wins by checkmate"),"black"):this.isInCheckmate(e,"black")?(console.log("[StandardChessModel] White wins by checkmate"),"white"):this.isStalemate(e)?(console.log("[StandardChessModel] Stalemate"),"draw"):this.isThreefoldRepetition(e)?(console.log("[StandardChessModel] Threefold repetition"),"draw"):this.isInsufficientMaterial(e)?(console.log("[StandardChessModel] Insufficient material"),"draw"):null:(console.log("[StandardChessModel] Both kings are missing"),"draw"):(console.log("[StandardChessModel] Black king is missing"),"white"):(console.log("[StandardChessModel] White king is missing"),"black")}getInitialState(){const e=this.getInitialBoardState();return{board:e,currentTurn:"white",moveHistory:new v(e),capturedPieces:{white:[],black:[]},gameMode:"head-to-head",gameOver:!1}}calculatePossibleMoves(e,t){const o=[],{x:i,y:r}=t.position,s="white"===t.color?1:-1;switch(t.type){case"pawn":if("white"===t.color&&4===r||"black"===t.color&&3===r){var n;let t=(null===(n=e.moveHistory)||void 0===n?void 0:n.moves)||[];const a=t.length>0?t[t.length-1]:null;a&&"pawn"===a.piece.type&&2===Math.abs(a.from.y-a.to.y)&&1===Math.abs(a.to.x-i)&&a.to.y===r&&o.push({x:a.to.x,y:r+s})}const a={x:i,y:r+s};if(this.isWithinBoardBounds(a)&&!this.getPieceAt(e,a)){o.push({x:i,y:r+s});const n=r+2*s;("white"===t.color&&1===r||"black"===t.color&&6===r)&&this.isWithinBoardBounds({x:i,y:n})&&!this.getPieceAt(e,{x:i,y:n})&&o.push({x:i,y:n})}[-1,1].forEach((n=>{const a={x:i+n,y:r+s};if(this.isWithinBoardBounds(a)){const i=this.getPieceAt(e,a);i&&i.color!==t.color&&o.push(a)}}));break;case"rook":o.push(...this.getStraightMoves(e,t));break;case"knight":[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach((e=>{let[t,s]=e;o.push({x:i+t,y:r+s})}));break;case"bishop":o.push(...this.getDiagonalMoves(e,t));break;case"queen":o.push(...this.getStraightMoves(e,t),...this.getDiagonalMoves(e,t));break;case"king":for(let s=-1;s<=1;s++)for(let n=-1;n<=1;n++)if(0!==s||0!==n){const a={x:i+s,y:r+n};if(this.isWithinBoardBounds(a)){const i=this.getPieceAt(e,a);i?i.color!==t.color&&o.push(a):o.push(a)}}const c=this.getPieceAt(e,{x:7,y:"white"===t.color?0:7});t.hasMoved||!c||"rook"!==c.type||c.hasMoved||this.getPieceAt(e,{x:i+1,y:r})||this.getPieceAt(e,{x:i+2,y:r})||o.push({x:i+2,y:r});const l=this.getPieceAt(e,{x:0,y:"white"===t.color?0:7});t.hasMoved||!l||"rook"!==l.type||l.hasMoved||this.getPieceAt(e,{x:i-1,y:r})||this.getPieceAt(e,{x:i-2,y:r})||this.getPieceAt(e,{x:i-3,y:r})||o.push({x:i-2,y:r})}return o.filter((o=>(!this.getPieceAt(e,o)||this.getPieceAt(e,o).color!==t.color)&&this.isWithinBoardBounds(o)))}isGameOver(e){return null!==this.getWinner(e)||this.isThreefoldRepetition(e)}isInCheck(e,t){const o=e.board.find((e=>"king"===e.type&&e.color===t));if(!o)return console.warn("No ".concat(t," king found on the board")),!0;const i="white"===t?"black":"white";return this.getAttackersOfSquare(e,o.position,i).length>0}isUnderAttack(e,t,o){return this.isPositionUnderAttack({board:e.board,currentTurn:o},l(t),o)}isInCheckmate(e,t){return e.board.find((e=>"king"===e.type&&e.color===t))?!!this.isInCheck(e,t)&&this.getPiecesByColor(e,t).every((t=>0===this.getLegalMovesForPiece(e,t).length)):(console.warn("No ".concat(t," king found on the board")),!0)}isStalemate(e){return!this.isInCheck(e,e.currentTurn)&&this.getPiecesByColor(e,e.currentTurn).every((t=>0===this.getLegalMovesForPiece(e,t).length))}getPiecesByColor(e,t){return e.board.filter((e=>e.color===t))}getLegalMovesForPiece(e,t){return this.calculatePossibleMoves(e,t).filter((o=>{const i=this.makeMove(e,{from:t.position,to:o,piece:t});return!this.isInCheck(i,t.color)}))}getPieceAt(e,t){const o=l(t);return e.board.find((e=>h(e.position,o)))||null}isWithinBoardBounds(e){return this.geometry.isWithinBoardBounds(e)}isPositionUnderAttack(e,t,o){return e.board.some((i=>i.color===o&&this.calculatePossibleMoves(e,i).some((e=>h(e,t)))))}isInsufficientMaterial(e){const t=e.board;if(t.length>4)return!1;if(t.every((e=>"king"===e.type)))return!0;if(3===t.length)return t.some((e=>"bishop"===e.type||"knight"===e.type));if(4===t.length){const e=t.filter((e=>"bishop"===e.type)),o=t.filter((e=>"knight"===e.type));if(2===e.length){return(e[0].position.x+e[0].position.y)%2===(e[1].position.x+e[1].position.y)%2}if(2===o.length)return!0}return!1}undoMove(e){const t=e.moveHistory.moves[e.moveHistory.moves.length-1];if(!t)return e;let o=new v(e.moveHistory.initialState,e.moveHistory.moves.slice(0,-1));o.undoneMoves=[t,...e.moveHistory.undoneMoves];const i={...e,board:[...e.board],currentTurn:"white"===e.currentTurn?"black":"white",moveHistory:o},r=this.getPieceAt(i,t.to);if(r&&(r.position=t.from),t.capturedPiece){i.board.push(t.capturedPiece);const e=t.capturedPiece.color;i.capturedPieces[e]=i.capturedPieces[e].filter((e=>e.id!==t.capturedPiece.id))}return i}redoMove(e){const t=e.moveHistory.undoneMoves[0];if(!t)return e;let o=new v(e.moveHistory.initialState,[...e.moveHistory.moves,t]);o.undoneMoves=e.moveHistory.undoneMoves.slice(1);const i={...e,board:[...e.board],currentTurn:"white"===e.currentTurn?"black":"white",moveHistory:o},r=this.getPieceAt(i,t.from);return r&&(r.position=t.to),t.capturedPiece&&(i.board=i.board.filter((e=>e.id!==t.capturedPiece.id)),i.capturedPieces[t.capturedPiece.color].push(t.capturedPiece)),i}importState(e){const t=JSON.parse(e);if(!t.board||!Array.isArray(t.board))throw new Error("Invalid state: board is missing or not an array");if(!t.currentTurn||"white"!==t.currentTurn&&"black"!==t.currentTurn)throw new Error("Invalid state: currentTurn is missing or invalid");if(t.moveHistory?t.moveHistory instanceof v||(t.moveHistory=new v(t.board,t.moveHistory._moves||[])):t.moveHistory=new v([]),!t.capturedPieces||"object"!==typeof t.capturedPieces)throw new Error("Invalid state: capturedPieces is missing or not an array");return t}exportState(e){return JSON.stringify(e)}getBoardStateString(e){return e.board.map((e=>"".concat(e.type).concat(e.color).concat(u(e.position)))).sort().join("")}getInitialBoardState(){const t=[],o=(o,i,r,s)=>{t.push({type:o,color:i,position:e(r,s),id:M(),hasMoved:!1})};o("rook","white",0,0),o("knight","white",1,0),o("bishop","white",2,0),o("queen","white",3,0),o("king","white",4,0),o("bishop","white",5,0),o("knight","white",6,0),o("rook","white",7,0);for(let e=0;e<8;e++)o("pawn","white",e,1);o("rook","black",0,7),o("knight","black",1,7),o("bishop","black",2,7),o("queen","black",3,7),o("king","black",4,7),o("bishop","black",5,7),o("knight","black",6,7),o("rook","black",7,7);for(let e=0;e<8;e++)o("pawn","black",e,6);return t}getStraightMoves(e,t){return this.getMovesInDirections(e,t,[[1,0],[-1,0],[0,1],[0,-1]])}getDiagonalMoves(e,t){return this.getMovesInDirections(e,t,[[1,1],[1,-1],[-1,1],[-1,-1]])}getMovesInDirections(e,t,o){const i=[],{x:r,y:s}=t.position;for(const[n,a]of o)for(let o=1;o<8;o++){const c=r+o*n,l=s+o*a;if(!this.isWithinBoardBounds({x:c,y:l}))break;const h=this.getPieceAt(e,{x:c,y:l});if(h){h.color!==t.color&&i.push({x:c,y:l});break}i.push({x:c,y:l})}return i}}class x{getBoardSize(e){return 3*this.radius*(this.radius+1)+1}getBoardPosition(e,t){return[0,0,0]}constructor(e){this.type="hex",this.radius=void 0,this.width=void 0,this.height=void 0,this.depth=void 0,this.minQ=void 0,this.maxQ=void 0,this.minR=void 0,this.maxR=void 0,this.minS=void 0,this.maxS=void 0,this.radius=e,this.width=2*e+1,this.height=2*e+1,this.depth=1,this.minQ=-e,this.maxQ=e,this.minR=-e,this.maxR=e,this.minS=-e,this.maxS=e}getAllPositions(){const e=[];for(let t=this.minQ;t<=this.maxQ;t++){const o=Math.max(this.minR,-t-this.maxS),i=Math.min(this.maxR,-t+this.maxS);for(let r=o;r<=i;r++)e.push({q:t,r:r,s:-t-r})}return e}isWithinBoardBounds(e){const{q:t,r:o,s:i}=e;return t>=this.minQ&&t<=this.maxQ&&o>=this.minR&&o<=this.maxR&&i>=this.minS&&i<=this.maxS}isValidPosition(e){return this.isWithinBoardBounds(e)}}class q{constructor(){this.geometry=void 0,this.geometry=new x(5)}calculatePossibleMoves(e,t){const o=[],i=t.position;switch(t.type){case"pawn":const r="white"===t.color?{q:0,r:-1,s:1}:{q:0,r:1,s:-1},s=this.addHexPositions(i,r);if(this.isWithinBoardBounds(s)&&!this.getPieceAt(e,s)&&(o.push(s),!t.hasMoved)){const t=this.addHexPositions(s,r);this.isWithinBoardBounds(t)&&!this.getPieceAt(e,t)&&o.push(t)}("white"===t.color?[{q:1,r:-1,s:0},{q:-1,r:0,s:1}]:[{q:1,r:0,s:-1},{q:-1,r:1,s:0}]).forEach((r=>{const s=this.addHexPositions(i,r);if(this.isWithinBoardBounds(s)){const i=this.getPieceAt(e,s);i&&i.color!==t.color&&o.push(s)}}));break;case"rook":this.getHexDirections().forEach((t=>{for(let r=1;;r++){const s={q:i.q+t.q*r,r:i.r+t.r*r,s:i.s+t.s*r};if(!this.isWithinBoardBounds(s))break;if(o.push(s),this.getPieceAt(e,s))break}}));break;case"knight":[{q:3,r:-2,s:-1},{q:3,r:-1,s:-2},{q:1,r:-3,s:2},{q:2,r:-3,s:1},{q:2,r:1,s:-3},{q:1,r:2,s:-3},{q:-3,r:2,s:1},{q:-3,r:1,s:2},{q:-1,r:3,s:-2},{q:-2,r:3,s:-1},{q:-2,r:-1,s:3},{q:-1,r:-2,s:3}].forEach((e=>{const t={q:i.q+e.q,r:i.r+e.r,s:i.s+e.s};this.isWithinBoardBounds(t)&&o.push(t)}));break;case"bishop":[{q:1,r:-2,s:1},{q:2,r:-1,s:-1},{q:1,r:1,s:-2},{q:-1,r:2,s:-1},{q:-2,r:1,s:1},{q:-1,r:-1,s:2}].forEach((t=>{for(let r=1;;r++){const s={q:i.q+t.q*r,r:i.r+t.r*r,s:i.s+t.s*r};if(!this.isWithinBoardBounds(s))break;if(o.push(s),this.getPieceAt(e,s))break}}));break;case"queen":[...this.getHexDirections(),{q:1,r:-2,s:1},{q:2,r:-1,s:-1},{q:1,r:1,s:-2},{q:-1,r:2,s:-1},{q:-2,r:1,s:1},{q:-1,r:-1,s:2}].forEach((t=>{for(let r=1;;r++){const s={q:i.q+t.q*r,r:i.r+t.r*r,s:i.s+t.s*r};if(!this.isWithinBoardBounds(s))break;if(o.push(s),this.getPieceAt(e,s))break}}));break;case"king":[...this.getHexDirections(),{q:1,r:-2,s:1},{q:2,r:-1,s:-1},{q:1,r:1,s:-2},{q:-1,r:2,s:-1},{q:-2,r:1,s:1},{q:-1,r:-1,s:2}].forEach((e=>{const t=this.addHexPositions(i,e);this.isWithinBoardBounds(t)&&o.push(t)}))}return o.filter((o=>(!this.getPieceAt(e,o)||this.getPieceAt(e,o).color!==t.color)&&this.isWithinBoardBounds(o)))}getLegalMovesForPiece(e,t){return this.calculatePossibleMoves(e,t).filter((o=>{const i=this.makeMove(e,{from:t.position,to:o,piece:t});return!this.isInCheck(i,t.color)}))}isPositionUnderAttack(e,t,o){return e.board.some((i=>i.color===o&&this.calculatePossibleMoves(e,i).some((e=>h(e,t)))))}makeMove(e,t){e.capturedPieces||(e.capturedPieces={white:[],black:[]});const o=e.board.find((e=>h(e.position,t.from)&&e.type===t.piece.type&&e.color===t.piece.color));if(!o)return console.warn("No ".concat(t.piece.color," ").concat(t.piece.type," found at position: ").concat(u(t.from))),e;const i=this.getPieceAt(e,t.to),r={...e,board:e.board.filter((e=>e.id!==o.id)),currentTurn:"white"===e.currentTurn?"black":"white",moveHistory:new v(e.moveHistory.initialState,e.moveHistory.moves).addMove(t),capturedPieces:{white:[...e.capturedPieces.white],black:[...e.capturedPieces.black]}};if(i&&(r.capturedPieces[i.color].push(i),r.board=r.board.filter((e=>e.id!==i.id))),"pawn"===o.type&&("white"===o.color&&-5===t.to.r||"black"===o.color&&5===t.to.r)){const e=t.promotionType||"queen";r.board.push({...o,position:t.to,hasMoved:!0,type:e})}else r.board.push({...o,position:t.to,hasMoved:!0});return r}getAttackersOfSquare(e,t,o){const i=l(t);return e.board.filter((t=>t.color===o&&this.calculatePossibleMoves(e,t).some((e=>h(e,i)))))}isLegalMove(e,t){const o=this.getPieceAt(e,t.from);return o?o.color!==e.currentTurn?(console.log("[HexChessModel] It's not ".concat(o.color,"'s turn")),!1):!!this.isWithinBoardBounds(t.to)&&!!this.getLegalMovesForPiece(e,o).some((e=>h(e,t.to))):(console.log("[HexChessModel] No piece found at position: ".concat(JSON.stringify(t.from))),!1)}isThreefoldRepetition(e){const t=e.moveHistory.moves.map((t=>this.getBoardStateString(e))).reduce(((e,t)=>(e[t]=(e[t]||0)+1,e)),{});return Object.values(t).some((e=>e>=3))}getWinner(e){const t=e.board.find((e=>"king"===e.type&&"white"===e.color)),o=e.board.find((e=>"king"===e.type&&"black"===e.color));return t?o?this.isInCheckmate(e,"white")?"black":this.isInCheckmate(e,"black")?"white":this.isStalemate(e)||this.isThreefoldRepetition(e)||this.isInsufficientMaterial(e)?"draw":null:"white":"black"}getInitialState(){const e=this.getInitialBoardState();return{board:e,currentTurn:"white",moveHistory:new v(e),capturedPieces:{white:[],black:[]},gameMode:"head-to-head",gameOver:!1}}isWithinBoardBounds(e){var t,o,i,r,s,n;const{q:a,r:c,s:l}=d(e);return a>=(null!==(t=this.geometry.minQ)&&void 0!==t?t:-1/0)&&a<=(null!==(o=this.geometry.maxQ)&&void 0!==o?o:1/0)&&c>=(null!==(i=this.geometry.minR)&&void 0!==i?i:-1/0)&&c<=(null!==(r=this.geometry.maxR)&&void 0!==r?r:1/0)&&l>=(null!==(s=this.geometry.minS)&&void 0!==s?s:-1/0)&&l<=(null!==(n=this.geometry.maxS)&&void 0!==n?n:1/0)}getHexDirections(){return[{q:1,r:-1,s:0},{q:1,r:0,s:-1},{q:0,r:-1,s:1},{q:0,r:1,s:-1},{q:-1,r:0,s:1},{q:-1,r:1,s:0}]}getEdgeNeighbors(e){return this.getHexDirections().map((t=>this.addHexPositions(e,t)))}addHexPositions(e,t){return{q:e.q+t.q,r:e.r+t.r,s:e.s+t.s}}isGameOver(e){return null!==this.getWinner(e)||this.isThreefoldRepetition(e)}isInCheck(e,t){const o=e.board.find((e=>"king"===e.type&&e.color===t));if(!o)return!1;const i="white"===t?"black":"white";return this.getAttackersOfSquare(e,o.position,i).length>0}isUnderAttack(e,t,o){return this.getAttackersOfSquare(e,t,o).length>0}isInCheckmate(e,t){return!!this.isInCheck(e,t)&&this.getPiecesByColor(e,t).every((t=>0===this.getLegalMovesForPiece(e,t).length))}isStalemate(e){return!this.isInCheck(e,e.currentTurn)&&this.getPiecesByColor(e,e.currentTurn).every((t=>0===this.getLegalMovesForPiece(e,t).length))}getPiecesByColor(e,t){return e.board.filter((e=>e.color===t))}calculatePossibleMovesForPieceType(e,t,o){return this.calculatePossibleMoves(e,{...t,type:o})}getPieceAt(e,t){const o=l(t);return e.board.find((e=>h(e.position,o)))||null}getVertexNeighbors(e){return this.getHexDirections().map(((t,o)=>{const i=this.getHexDirections()[(o+1)%6];return this.addHexPositions(e,this.addHexPositions(t,i))}))}isInsufficientMaterial(e){const t=e.board||[];if(t.length>4)return!1;if(t.every((e=>e&&"king"===e.type)))return!0;if(3===t.length)return t.some((e=>e&&("bishop"===e.type||"knight"===e.type)));if(4===t.length){if(2===t.filter((e=>e&&"bishop"===e.type)).length)return!0;if(2===t.filter((e=>e&&"knight"===e.type)).length)return!0}return!1}undoMove(e){const t=e.moveHistory.moves[e.moveHistory.moves.length-1];if(!t)return e;let o=new v(e.moveHistory.initialState,e.moveHistory.moves.slice(0,-1));o.undoneMoves=[t,...e.moveHistory.undoneMoves];const i={...e,board:[...e.board],currentTurn:"white"===e.currentTurn?"black":"white",moveHistory:o},r=this.getPieceAt(i,t.to);if(r&&(r.position=t.from,r.hasMoved=!t.isFirstMove),t.capturedPiece){i.board.push(t.capturedPiece);const e=t.capturedPiece.color;i.capturedPieces[e]=i.capturedPieces[e].filter((e=>e.id!==t.capturedPiece.id))}return i}redoMove(e){const t=e.moveHistory.undoneMoves[0];if(!t)return e;let o=new v(e.moveHistory.initialState,[...e.moveHistory.moves,t]);o.undoneMoves=e.moveHistory.undoneMoves.slice(1);const i={...e,board:[...e.board],currentTurn:"white"===e.currentTurn?"black":"white",moveHistory:o},r=this.getPieceAt(i,t.from);return r&&(r.position=t.to,r.hasMoved=!0),t.capturedPiece&&(i.board=i.board.filter((e=>e.id!==t.capturedPiece.id)),i.capturedPieces[t.capturedPiece.color].push(t.capturedPiece)),i}importState(e){const t=JSON.parse(e);if(!t.board||!Array.isArray(t.board))throw new Error("Invalid state: board is missing or not an array");if(!t.currentTurn||"white"!==t.currentTurn&&"black"!==t.currentTurn)throw new Error("Invalid state: currentTurn is missing or invalid");if(t.moveHistory?t.moveHistory instanceof v||(t.moveHistory=new v(t.board,t.moveHistory._moves||[])):t.moveHistory=new v([]),!t.capturedPieces||"object"!==typeof t.capturedPieces)throw new Error("Invalid state: capturedPieces is missing or not an object");return t}exportState(e){return JSON.stringify(e)}getBoardStateString(e){return e.board.map((e=>"".concat(e.type).concat(e.color).concat(u(e.position)))).sort().join("")}getInitialBoardState(){const e=[],t=(t,o,i,r,s)=>{e.push({type:t,color:o,position:{q:i,r:r,s:s},id:M(),hasMoved:!1})};let o=-2,i=5,r=-o-i;t("rook","white",r++,i,o--),t("knight","white",r++,i,o--),t("queen","white",r++,i,o--),t("bishop","white",r,i-1,o),t("bishop","white",r,i-2,o),t("bishop","white",r++,i--,o),t("king","white",r++,i--,o),t("knight","white",r++,i--,o),t("rook","white",r++,i--,o),o=-1,i=5,r=-o-i;for(let s=0;s<4;s++)t("pawn","white",r++,i--,o);for(let s=0;s<5;s++)t("pawn","white",r++,i,o--);o=2,i=-5,r=-o-i,t("rook","black",r--,i,o++),t("knight","black",r--,i,o++),t("queen","black",r--,i,o++),t("bishop","black",r,i+1,o),t("bishop","black",r,i+2,o),t("bishop","black",r--,i++,o),t("king","black",r--,i++,o),t("knight","black",r--,i++,o),t("rook","black",r--,i++,o),o=1,i=-5,r=-o-i;for(let s=0;s<4;s++)t("pawn","black",r--,i++,o);for(let s=0;s<5;s++)t("pawn","black",r--,i,o++);return e}}const I={depthLimit:2,timeLimit:3e3,randomnessFactor:.1,verbosityLevel:0};let A=null,B=null;self.onmessage=async e=>{const{type:t,currentState:o,aiConfig:i=I,gameType:r}=e.data||{};if(!t)return console.error("Invalid message type received in worker",e.data),void self.postMessage({type:"error",error:"Invalid message type"});switch(t){case"init":!function(e,t){const o={...I,...e};console.log("Initializing AI for ".concat(t," chess with config:"),o),A=new g,B="standard"===t?new S:new q,A.initialize(B,o),console.log("AI initialized successfully"),self.postMessage({type:"status",message:"AI initialized"})}(i,r);break;case"calculate":if(!o)return void self.postMessage({type:"error",error:"Invalid game state received in worker"});!async function(e){if(!A||!B)return console.error("AI or game model not initialized"),void self.postMessage({type:"error",error:"AI not initialized"});self.postMessage({type:"status",message:"AI calculation started"});try{console.log("AI calculation started");const t=await A.calculateBestMove(e);console.log("Best move found: ".concat(t)),t?self.postMessage({type:"move",move:t}):self.postMessage({type:"error",error:"No valid move found"})}catch(t){!function(e){e instanceof Error?"AbortError"===e.name?(console.log("AI calculation aborted"),self.postMessage({type:"status",message:"AI calculation aborted"})):(console.error("AI calculation error:",e),self.postMessage({type:"error",error:e.message})):(console.error("Unknown error occurred:",e),self.postMessage({type:"error",error:"An unknown error occurred"}))}(t)}}(o);break;case"abort":A&&(A.abortCalculation(),self.postMessage({type:"status",message:"AI calculation aborted"}));break;default:console.error("Unknown message type:",t),self.postMessage({type:"error",error:"Unknown message type"})}}})();